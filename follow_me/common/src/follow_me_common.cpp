/**
* @file follow_me_common.cpp
* @author Norawit Nangsue
*
* Copyright (C) FIBO
*
* @brief follow_me
*        This file is to be edited by the Developer
**/

// ROS message includes
#include "ros/ros.h"

// ROS message & services includes

// ROS message & services includes
#include <geometry_msgs/Twist.h>
#include <std_msgs/String.h>
#include <object_msgs/ObjectsInBoxes.h>
#include <sensor_msgs/Image.h>
#include <std_srvs/SetBool.h>


/* protected region user include files begin */
#include <string>
#include <cmath>
/* protected region user include files end */

/**
 * @class FollowMeConfig
 * @brief set of static and dynamic parameters
 * @warning this class is autogenerated. It should not be touched!
 */
class FollowMeConfig
{
public:
    // parameters handled through the parameter server
    double Kp_x;
    double Kp_a;
    double vx_max;
    double wz_max;
    double min_dist_fol;
    double max_dist_fol;
    double prob_thres;
    //! overloading the print operator
    friend std::ostream& operator<< (std::ostream& os,
                                     const FollowMeConfig& config)
    {
        os << "Kp_x: " << config.Kp_x << std::endl;
        os << "Kp_a: " << config.Kp_a << std::endl;
        os << "vx_max: " << config.vx_max << std::endl;
        os << "wz_max: " << config.wz_max << std::endl;
        os << "min_dist_fol: " << config.min_dist_fol << std::endl;
        os << "max_dist_fol: " << config.max_dist_fol << std::endl;
        os << "prob_thres: " << config.prob_thres << std::endl;
        return os;
    }
};

/**
 * @class FollowMeData
 * @brief set of input / output handled through the update methods
 * @warning this class is autogenerated. It should not be touched!
 */
class FollowMeData
{
public:
    // input data
    object_msgs::ObjectsInBoxes in_detected_people;
    bool in_detected_people_updated;
    sensor_msgs::Image in_depth_image;
    bool in_depth_image_updated;
    // output data
    geometry_msgs::Twist out_cmd_vel;
    bool out_cmd_vel_active;
    std_msgs::String out_status;
    bool out_status_active;
};

/**
 * @class FollowMeImpl
 * @brief Implementation of the node intelligence
 * @warning this class is be filled by the Developer, at locations indicated
 */
class FollowMeImpl
{
    /* protected region user member variables begin */
private:
    bool following;
    bool stopped;
    /* protected region user member variables end */

public:
    /**
     * @brief constructor
     */
    FollowMeImpl(): following(false), stopped(false)
    {
        /* protected region user constructor begin */
        //         double Kp_x;
        // double Kp_a;
        // double min_dist_fol;
        // double max_dist_fol;
        // double prob_thres;
        // int cam_height;
        // int cam_width;
        // std::string follow_me_status;
        /* protected region user constructor end */
    }
    /**
     * @brief destructor
     */
    ~FollowMeImpl()
    {
        /* protected region user destructor begin */
        /* protected region user destructor end */
    }
    /**
     * @brief method called at node configuration
     * @param config set of configuration parameters available
     */
    void configure(FollowMeConfig config)
    {
        /* protected region user configure begin */
        /* protected region user configure end */
    }
    /**
     * @brief Update method periodically called by the ros component
     * @param data contains received messages (through subscription), and will contain messages to publish
     * @param config latest state of the config variables
     */
    void update(FollowMeData &data, FollowMeConfig config)
    {
        /* protected region user update begin */

        /*When there's human and following, Get Nearest Human in the scene*/
        if (data.in_detected_people.objects_vector.size() > 0 && following)
        {
            double selected_depth = 65535;
            pair<double, double> selected_center;
            for (auto m : data.in_detected_people.objects_vector)
            {
                pair<double, double> detected_center; /*x, y*/
                detected_center.first = data.in_detected_people.objects_vector[0].roi.x_offset + data.in_detected_people.objects_vector[0].roi.width / 2;
                detected_center.second = data.in_detected_people.objects_vector[0].roi.y_offset + data.in_detected_people.objects_vector[0].roi.height / 2;

                if (data.in_depth_image.encoding != "16UC1")
                {
                    ROS_ERROR("Encoing not supported");
                    return;
                }

                if (data.in_depth_image.is_bigendiant != 0)
                {
                    ROS_ERROR("Encoing not supported, support only Little Endiant");
                    return;
                }

                uint8_t depth_l = in_depth_image.data[detected_center.first + detected_center.second * in_depth_image.data.step];
                uint8_t depth_h = in_depth_image.data[detected_center.first + detected_center.second * in_depth_image.data.step + 1];
                double detected_depth = static_cast<double>(depth_h * 255 + depth_l) / 1000;
                
                if(detected_depth < selected_depth) {
                    selected_depth = detected_depth;
                    selected_center.first = detected_center.first;
                    selected_center.second = detected_center.second;
                }
            }
            /*When human within range*/
            if(selected_depth >= config.min_dist_fol && selected_depth <= config.max_dist_fol){
                /*Control in theta-direction*/
                double control_z = config.Kp_a * (detected_center.width / 2 - selected_center.first);
                if(std::abs(control_z) > config.wz_max){
                    control_z = control_z / std::abs(control_z) * config.wz_max;
                }
                data.out_cmd_vel.angular.z = control_z;

                /*Control in x-direction*/
                double control_x = config.Kp_x * -(control.min_dist_fol - selected_depth);            
                if(control_x > 0){
                    if(control_x > config.vx_max){
                        control_x = config.vx_max;
                    }
                    data.out_cmd_vel.linear.x = control_x;
                } else {
                    data.out_cmd_vel.linear.x = 0;
                }
            } else {/*When human outside range, send zero velocity*/

                data.out_cmd_vel.linear.x = 0;
                data.out_cmd_vel.angular.z = 0;
            }

        }
        else
        {
            //Send Zero Velocity
            if (!stopped)
            {
                data.out_cmd_vel.linear.x = 0;
                data.out_cmd_vel.angular.z = 0;
                config.out_cmd_vel_active = true;
                stopped = true;
            }
            else
            {
                config.out_cmd_vel_active = false;
            }
        }
        /* protected region user update end */
    }

    /**
     * @brief callback of a service request
     * @param req input parameters provided by the caller
     * @param res output parameters resulting from the service execution
     * @param config latest state of the config variables
     */
    bool callback_command(std_srvs::SetBool::Request  &req, std_srvs::SetBool::Response &res , FollowMeConfig * config)
    {
        /* protected region user implementation of service callback for command begin */
        /* protected region user implementation of service callback for command end */
        // todo remove that return
        return true;
    }
    /* protected region user additional functions begin */
    /* protected region user additional functions end */
};
